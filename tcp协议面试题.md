# tcp面试题



## 一. 什么是滑动窗口？



**定义：**滑动窗口是一种流量控制技术。

**背景：**早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。

**原理：（如何进行流量控制的呢？）**

① 缓存：发送方和接收方会各自维护自己的缓存（TODO？缓存多大），各自会有两个环形队列的缓冲区：发送缓冲区、接收缓冲区

​	可用缓存大小：即TCP头部的窗口大小。表明自己作为接收端的可用缓存空间的大小（win_size * win_scale）

![滑动窗口可视化]([D:\Protocol_Note\images\tcp\滑动窗口可视化.jpg](https://github.com/mohemohemohe/Protocol_Note/blob/main/images/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%AF%E8%A7%86%E5%8C%96.jpg))

②滑动窗口机制：当接收方收到ACK后，滑动窗口向右移动。

​	若当前ACK前还有数据未收到，滑动窗口也会往后移动。

​	有效窗口大小 = 发送但未被确认 + 准备发送

③socket send将数据放到哪了？——注意：指定了是tcp协议族

​	交给TCP的发送缓冲区？

④socket recv接收数据到哪了？——注意：指定了是tcp协议族

​	交给tcp的接收缓冲区

## 二. 拔掉网线后，TCP连接还存在吗？



可能存在也可能不存在： 拔掉网线的瞬间，其实无论是客户端还是服务端，维持 TCP 连接的 handle 还是在的。问题就在于多少时间，多少时间客户端上的进程意识到网线被拔了；多少时间服务端上的进程意识到客户端已经停止响应了。 

**拔掉网线的瞬间，可细分为以下几种情况：**

①有数据传输：

​	触发超时重传上限：在linux参数中tcp_retries为重传的次数15，且RTT比较小，那么RTO初始值约等于下限200ms，大概得要900+ 秒TCP才会通知应用程序断开连接。

```bash
cat /proc/sys/net/ipv4/tcp_retries 
//如果第15次还是没有接收到对方给我的确认，这时TCP会认为TCP连接已经断开，这时候会断开连接
```

​	在超时重传上限内，网络恢复了，程序员无感知。

②没有数据传输：触发心跳机制

​	

## 三、介绍tcp3 次握手的过程

注意的3个点：

①3次握手中双方发送的数据包名称：syn，syn+ack，ack

②三次握手中连接双方的状态：客户端（closed，syn_send, establised）,服务器端（closed， listen，syn_received，established）

③三次握手中双方发送的数据包序号：syn(seq=x)，syn+ack(seq=y，ack=x+1)，ack(seq=x+1, ack=y+1)

**补充**：syn，syn+ack阶段不可以发送应用数据：还没确认建立好连接，如何接收来自应用层数据，容易收到非法攻击。

​		   ack阶段可以：发出ack时就已经可以确认双方都处于established状态了，可以携带应用层数据。



### 四、ACK消耗TCP序号吗？

![1709390734877](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709390734877.png)

![1709390755827](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709390755827.png)

延伸的题：

①3次握手改成2次行不？为啥？

②TCP 3次握手可以携带应用层数据吗？



序号：TCP为保证数据有序到达对端，因此TCP设置了序号来保证。序号长度为32bit，序号最大长度为 65535。

ACK数据包：

​	1. 3次握手过程中的syn+ack, ack：syn+ack消耗一个序号，ack不消耗

​	2. 4次握手中的fin+ack, ack：fin+ack消耗一个序号，ack不消耗

	3. estabilshed中的ack，psh+ack：不消耗序号，每个序号都对应一个字节的应用层数据。

![ACK消耗序号：syn+ack](D:\Protocol_Note\images\tcp\ACK消耗序号：syn+ack.jpg)

## ![ACK消耗序号：established ack](D:\Protocol_Note\images\tcp\ACK消耗序号：established ack.jpg)

![ACK消耗序号：fin+ack](D:\Protocol_Note\images\tcp\ACK消耗序号：fin+ack.jpg)



## 五、3次握手改成2次握手可以吗？

不可以。因为无法确认发送方的接收状态是否是正常的。具体分析如下：

前两次握手只能确认客户端的发送、服务端的发送能力和接收正常的，只有第三次握手当客户端对syn+ack 进行ack后，才能确认客户端的接收能力是正常的。



## 六、请简述TCP/IP模型中每层的作用及每层的典型协议和典型设备。

tcp/ip 的5层模型：物理层、数据链路层、网络层、传输层、应用层

物理层协议有：以太网协议，典型的设备如集线器、中继器等，主要负责将光电信号转换为二进制数据，或者将二进制数据转换为光电信号。

数据链路层协议有：以太网协议，典型设备如交换机，主要负责相邻设备之间的传输，负责将数据从A节点传输到B节点。

网络层协议有：IP协议、ICMAP协议、BGP协议，典型的设备如路由器，主要负责路由选择，为网络数据选择一条合适的路由。

传输层协议有：TCP、UDP协议。由于是端到端的协议，没有典型设备。

应用层协议有：http、https、ftp等。网络数据来源于进程，没有典型设备。





## 七、介绍tcp 4次挥手的过程

注意的3个点：

①4次挥手中双方发送的数据包名称：客户端(fin, ack)   服务器端 (fin, ack)

②4次挥手中连接双方的状态：

​	客户端（fin_wait1, fin_wait1, time_wait 2MSL，closed）   

​	服务器端（closed_wait，last_ack，closed）

③4次挥手中双方发送的数据包序号

​	客户端（fin(seq = M)，ack（seq = ？，ack=M+1））

​	服务器端（fin(seq = N)，ack（seq = ？，ack=N+1））



## 八、主动断开连接方，为什么要等待 2MSL 时间？

MSL：报文最大生存时间，即报文在网络上存在的最长时间

为了防止主动断开连接方发送的ACK丢失，被动断开连接方会重传FIN报文。具体如下：

主动断开连接方接收到被动断开连接方发送的fin报文后，变成了TIME_WAIT状态，就是由于存在发送的ACK报文在网络中丢失，那么被动断开连接方会重传FIN报文，因此 **2MSL=主动断开连接方发送的ACK报文的MSL + 被动断开连接方重传的 MSL**



## 九、如果服务端不进行accept，那么最多可以完成多少个连接？

```
//socket: 侦听套接字， backLog: 已完成连接队列的大小
listen(int socket, int backlog)

1.未完成连接队列: 存放的是正在进行3次握手的连接
2.已完成连接队列：已完成3次握手的连接
```

服务器端会将连接分为未完成连接队列 和 已完成连接队列，未完成连接队列中的已完成连接后会被放入已完成连接队列中，若不进行accept的话，最多可以完成 backlog+1 个连接。



![1709437367778](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709437367778.png)

## 十、服务端最多可以完成多少个TCP连接？

- 服务端完成TCP连接的个数是取决于操作系统的上限
- 操作系统会规定一个值，open files来规定一个进程最多可以打开多少个文件描述符
-  我的机器中看到的是1024，意味着最多能够打开1024个文件描述符，意味着服务端最多可以完成的TCP连接数为1024-3-1，3是一个进程默认的标准输入，标准输出，标准错误，1表示侦听套接字
- 当然open files的值可以通过ulimit -n来进行修改

我的Debian参数查看情况：

cat /proc/sys/fs/file-max : 查看系统所有进程打开的文件描述符数不能超过这个file-max

ulimit -n：单个进程打开的文件描述符不能超过这个，可设置，但是不能超过 最大上限(ulimit -Hn)

ulimit -Hn：单个进程打开的文件描述数符的上限

![文件描述符个数](D:\Protocol_Note\images\tcp\文件描述符个数.jpg)



## 十一、三次握手中连接序号一定是从0开始吗？

一般不从0开始，除非溢出，初始序号是动态的，
1.初始化序号可以看作是32位计数器，这样选择序号的目的在于防止被网络延迟的分组后续又被传输，从而导致错误的解释
2.三次握手中，客户端和服务端互相交换初始化序号，之后的数据包就按照约定的初始化序号向下使用。如果固定为0，则会导致网络攻击者很容易模拟TCP数据包，来攻击服务端。



## 十二、三次握手中，为什么要协商MSS的长度

MSS（max segment size）：**TCP最大传输报文长度**，意思是TCP将数据递交给网络层的数据大小。
在三次握手时，双方就MSS大小进行协商，取其较小值。
协商的目的是：
1.如果没有进行协商，如果传递的数据包过大，递交给网络层之后，IP协议会进行分片，而IP协议是不可靠的，如果发生一个分片丢失，那么TCP会认为整个数据包丢失，会重传整个TCP数据包。

2.ip数据丢包，导致重传会造成恶性循环，导致网络的拥塞更严重，转发能力就会越差。

3.如果TCP交给网络层的数据大小满足MSS，那么IP协议不会进行分片传输。



补充细节：

​	client->server: MSS=1460

​	server->lient: MSS=1420

​	连接中最终的MSS=1420， 两者中取小的



## 十三、服务端出现大量close_wait状态，是什么原因，有什么危害，应该怎么办？

close_wait状态只会出现在四次挥手的被动断开连接方，也就意味着服务端是被动断开连接方。

转化问题：被动断开连接方为什么没有发送fin包 =》为什么没有调用close函数？

只有当主动断开连接方发送给被动断开连接方FIN报文之后，被动断开连接方才会从estbalish状态转换到close_wait状态，而进一步转换到 last_ack状态 需要**被动断开连接方调用close函数，进行关闭的操作**。

如果服务端出现大量close_wait状态，**说明服务端没有调用close函数**，进一步的原因可能是多方位的：
1. close函数被阻塞
2. 执行close函数的线程，在执行到close之前有非常耗时的操作
3. 根据实际情况看还有其他的可能导致没有调用到close函数（业务上的大量close_wait可以从业务的角度去分析产生此问题的原因）

危害：会导致占用大量的服务端资源



## 十四、TCP维护的序号最大是多少，超出最大值后序号是多少？

按照TCP包头中32位序号来看，维护的序号范围是0–>4294967295

当超出这个序号的最大范围后，就会发生**“序号回绕”**，也就是从最大值回到0开始继续向后走。

用无符号char类型来举例：0-255的范围
如果当前序号在254，接下来有一个4字节的数据包，TCP维护的序号就是255->0->1->2，接下来的序号就是3.

## 十五、什么是确认应答机制？

当发送方发送一个数据包，接收方需要进行接收确认，返回ack来确认收到了这个数据包
而确认的本质是在确认序号。而序号本质上就是数据，因为TCP对应用层的每个字节都进行了编号



## 十六、超时重传时间是固定的吗？怎么计算？

超时重传时间（RTO）是不固定的，是随着报文往返时间（RTT）进行动态变化的。
简单的说：RTT时间小，说明网络情况好，则RTO变小，RTT时间长，说明网络情况查，则RTO变大。



## 十七、什么是快重传？快重传存在效率问题吗？

快重传是为了在没有触发超时重传的时候，就触发发送方传递了数据。本质上是为了提高传输效率的

做法：当发送方连续收到三次同样的确认数据包，就会触发快重传，立即发送丢失的数据包。

是存在效率问题的：主要问题就是当序号为A的数据包已经后续的几个数据包都丢失之后，那么虽然对当前的数据包进行了快重传，但是后续丢失的数据包也需要再次等3次同样的数据包才能触发快重传，这样会导致效率较低。

解决办法 SACK，在TCP头部的40字节选项中，描述接收方收到了哪些数据包，那么在发送方来说，就会知道哪些数据包丢失了，就会触发快重传进行发送。



## 十八、理解TCP的缓冲区

TCP的缓冲区是操作系统内核中的一块空间。
1.发送缓冲区和接收缓冲区都是环形队列
2.调用send函数，进程产生的数据会被放到发送缓冲区中，TCP会择机将缓冲区的数据发送；
3.调用recv函数，会从TCP的接收缓冲区中将数据拷贝到准备好的空间



## 十九、理解滑动窗口中的窗口

窗口就是TCP允许暂时不需要收到ACK确认的报文

操作系统会将发送缓冲区分为：已经发送并且已经确认收到的区域，已经发送暂时不需要确认的区域，可以发送但未发送的区域，不能发送的区域。

当收到靠后的ack确认之后，窗口可以向后滑动吗？
可以，因为当收到靠后的ack确认之后，意味着靠前的数据包对方是收到的，因此哪些数据包就不需要再保存了，窗口就可以向后滑动了



## 二十、SYN报文什么情况会被丢弃？

2个原因：

​	①TCP两个队列满了，造成SYN报文被丢弃。 注：两个队列（半连接队列、已连接队列）

​	②开启tcp_tw_recycle参数，并且在NAT环境下，造成SYN报文被丢弃



具体分析：

1、半连接队列满了

大量的syn数据包，同时间到达服务端，导致半连接队列瞬间打满，多余的syn就丢弃了。

多余的syn可能产生的原因：syn flood泛洪攻击

**解决方案：**

​	①增大队列：需要同时增大半连接队列(tcp_max_syn_backlog) 和 全连接队列(somaxconn、backlog)

```
/proc/sys/net/ipv4/tcp_max_syn_backlog //半连接队列的大小
/proc/sys/net/core/somaxconn
```

​	②开启tcp_syncookies功能：

​	③减少syn+ack重传次数：

![1709437367778](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709437367778.png)
